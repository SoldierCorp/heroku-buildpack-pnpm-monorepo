#!/usr/bin/env bash
set -euo pipefail

# Heroku buildpack compile script
# Usage: bin/compile <build_dir> <cache_dir> <env_dir>

BUILD_DIR="${1:-}"
CACHE_DIR="${2:-}"
ENV_DIR="${3:-}"

if [ -z "$BUILD_DIR" ]; then
  echo "Error: build directory not provided to compile script" >&2
  exit 1
fi

cd "$BUILD_DIR"

# Install pnpm if not already available
if ! command -v pnpm >/dev/null 2>&1; then
  echo "Installing pnpm..."
  curl -fsSL https://get.pnpm.io/install.sh | SHELL=bash bash -
  export PNPM_HOME="$HOME/.local/share/pnpm"
  export PATH="$PNPM_HOME:$PATH"
fi

# Ensure there's a package.json at repo root (we run installs from root)
if [ ! -f package.json ]; then
  echo "Error: No package.json found in project root ($BUILD_DIR)" >&2
  exit 1
fi

echo "Installing dependencies from monorepo root (pnpm) (ignoring lifecycle scripts)..."
# Prevent Husky and other dev hooks from running during the build
export HUSKY=0
# Use workspace-root install so pnpm recognizes workspace packages regardless of cwd
if ! pnpm -w install --frozen-lockfile --ignore-scripts; then
  echo "pnpm -w install --frozen-lockfile --ignore-scripts failed, attempting pnpm -w install --ignore-scripts without lockfile flag..."
  if ! pnpm -w install --ignore-scripts; then
    echo "pnpm install failed. If you see an error about a workspace package missing (e.g. \"@leangap/types@workspace:*\"), ensure that:
  1) the package exists under your workspace (packages/* or similar),
  2) it's listed by your pnpm-workspace.yaml (or matches the workspace glob), and
  3) package.json 'name' fields match the workspace dependency names." >&2
    exit 1
  fi
fi

# If Heroku passed env vars via ENV_DIR, read them into the environment so we can use them
if [ -n "${ENV_DIR:-}" ] && [ -d "${ENV_DIR}" ]; then
  for f in APP_DIR APP_NAME APP_FILTER; do
    if [ -z "${!f:-}" ] && [ -f "$ENV_DIR/$f" ]; then
      export "$f"="$(cat "$ENV_DIR/$f")"
    fi
  done
fi

# Determine target directory: prefer APP_DIR (relative path), else locate by APP_NAME (package.json name)
TARGET_DIR=""
echo "DEBUG: APP_DIR='${APP_DIR:-}' APP_NAME='${APP_NAME:-}' APP_FILTER='${APP_FILTER:-}' (read from ENV_DIR if present)"

# 1) Prefer explicit APP_DIR
if [ -n "${APP_DIR:-}" ]; then
  TARGET_DIR="$BUILD_DIR/${APP_DIR#./}"
fi

# 2) Support APP_FILTER (alias for some buildpacks)
if [ -z "$TARGET_DIR" ] && [ -n "${APP_FILTER:-}" ]; then
  TARGET_DIR="$BUILD_DIR/${APP_FILTER#./}"
fi

# 3) Try APP_NAME matching with several fallbacks
if [ -z "$TARGET_DIR" ] && [ -n "${APP_NAME:-}" ]; then
  echo "Searching for package with name ${APP_NAME} under $BUILD_DIR"
  # exact match
  FOUND=$(grep -Rls "\"name\": *\"${APP_NAME}\"" "$BUILD_DIR" 2>/dev/null || true)
  if [ -n "$FOUND" ]; then
    TARGET_DIR=$(dirname "$(echo "$FOUND" | head -n1)")
  else
    # try unscoped name (part after the slash)
    UNSCOPED=$(echo "$APP_NAME" | sed 's@.*/@@')
    echo "DEBUG: trying unscoped name '$UNSCOPED'"
    FOUND2=$(grep -Rls -E "\"name\": *\"(.*/)?${UNSCOPED}\"" "$BUILD_DIR" 2>/dev/null || true)
    if [ -n "$FOUND2" ]; then
      TARGET_DIR=$(dirname "$(echo "$FOUND2" | head -n1)")
    else
      # try derive path by taking the part after the slash, e.g., @app/web -> apps/web
      POSSIBLE="$BUILD_DIR/apps/$UNSCOPED"
      echo "DEBUG: checking derived path '$POSSIBLE'"
      if [ -d "$POSSIBLE" ]; then
        TARGET_DIR="$POSSIBLE"
      fi
    fi
  fi
fi

# 4) Last resort: try to find any apps/* package.json whose name matches end with the unscoped name
if [ -z "$TARGET_DIR" ]; then
  echo "DEBUG: listing candidate package.json files under apps/"
  ls -R apps 2>/dev/null || true
fi

if [ -z "$TARGET_DIR" ]; then
  echo "Error: could not determine target app directory. Set APP_DIR (e.g. apps/web) or APP_NAME (package.json name)." >&2
  exit 1
fi

if [ ! -d "$TARGET_DIR" ]; then
  echo "Error: resolved TARGET_DIR ($TARGET_DIR) does not exist." >&2
  exit 1
fi

REL_TARGET=${TARGET_DIR#${BUILD_DIR}/}
echo "Building app in $TARGET_DIR (workspace filter: ./"$REL_TARGET" )"

# Check that package.json has a build script
if [ ! -f "$TARGET_DIR/package.json" ] || ! grep -q '"build"' "$TARGET_DIR/package.json"; then
  echo "Error: no \"build\" script found in $TARGET_DIR/package.json" >&2
  exit 1
fi

# Run the build from the workspace root using a path filter so pnpm understands workspace:* deps
cd "$BUILD_DIR"
pnpm --filter "./$REL_TARGET" run build

#!/usr/bin/env bash
set -euo pipefail

# Heroku buildpack compile script
# Usage: bin/compile <build_dir> <cache_dir> <env_dir>

BUILD_DIR="${1:-}"
CACHE_DIR="${2:-}"
ENV_DIR="${3:-}"

if [ -z "$BUILD_DIR" ]; then
  echo "Error: build directory not provided to compile script" >&2
  exit 1
fi

cd "$BUILD_DIR"

# Install pnpm if not already available
if ! command -v pnpm >/dev/null 2>&1; then
  echo "Installing pnpm..."
  curl -fsSL https://get.pnpm.io/install.sh | SHELL=bash bash -
  export PNPM_HOME="$HOME/.local/share/pnpm"
  export PATH="$PNPM_HOME:$PATH"
fi

# Ensure there's a package.json at repo root (we run installs from root)
if [ ! -f package.json ]; then
  echo "Error: No package.json found in project root ($BUILD_DIR)" >&2
  exit 1
fi

echo "Ensuring pnpm is available; skipping dependency install in helper. heroku/nodejs will run the actual install/build."
if ! command -v pnpm >/dev/null 2>&1; then
  echo "pnpm not found after bootstrap; attempting install..."
  curl -fsSL https://get.pnpm.io/install.sh | SHELL=bash bash -
  export PNPM_HOME="$HOME/.local/share/pnpm"
  export PATH="$PNPM_HOME:$PATH"
fi

# If Heroku passed env vars via ENV_DIR, read them into the environment so we can use them
if [ -n "${ENV_DIR:-}" ] && [ -d "${ENV_DIR}" ]; then
  for f in APP_DIR APP_NAME APP_FILTER; do
    if [ -z "${!f:-}" ] && [ -f "$ENV_DIR/$f" ]; then
      export "$f"="$(cat "$ENV_DIR/$f")"
    fi
  done
fi

# Determine target directory: prefer APP_DIR (relative path), else locate by APP_NAME (package.json name)
TARGET_DIR=""
echo "DEBUG: APP_DIR='${APP_DIR:-}' APP_NAME='${APP_NAME:-}' APP_FILTER='${APP_FILTER:-}' (read from ENV_DIR if present)"

# 1) Prefer explicit APP_DIR
if [ -n "${APP_DIR:-}" ]; then
  TARGET_DIR="$BUILD_DIR/${APP_DIR#./}"
fi

# 2) Support APP_FILTER (alias for some buildpacks)
if [ -z "$TARGET_DIR" ] && [ -n "${APP_FILTER:-}" ]; then
  TARGET_DIR="$BUILD_DIR/${APP_FILTER#./}"
fi

# 3) Try APP_NAME matching with several fallbacks
if [ -z "$TARGET_DIR" ] && [ -n "${APP_NAME:-}" ]; then
  echo "Searching for package with name ${APP_NAME} under $BUILD_DIR"
  # exact match
  FOUND=$(grep -Rls "\"name\": *\"${APP_NAME}\"" "$BUILD_DIR" 2>/dev/null || true)
  if [ -n "$FOUND" ]; then
    TARGET_DIR=$(dirname "$(echo "$FOUND" | head -n1)")
  else
    # try unscoped name (part after the slash)
    UNSCOPED=$(echo "$APP_NAME" | sed 's@.*/@@')
    echo "DEBUG: trying unscoped name '$UNSCOPED'"
    FOUND2=$(grep -Rls -E "\"name\": *\"(.*/)?${UNSCOPED}\"" "$BUILD_DIR" 2>/dev/null || true)
    if [ -n "$FOUND2" ]; then
      TARGET_DIR=$(dirname "$(echo "$FOUND2" | head -n1)")
    else
      # try derive path by taking the part after the slash, e.g., @app/web -> apps/web
      POSSIBLE="$BUILD_DIR/apps/$UNSCOPED"
      echo "DEBUG: checking derived path '$POSSIBLE'"
      if [ -d "$POSSIBLE" ]; then
        TARGET_DIR="$POSSIBLE"
      fi
    fi
  fi
fi

# 4) Last resort: try to find any apps/* package.json whose name matches end with the unscoped name
if [ -z "$TARGET_DIR" ]; then
  echo "DEBUG: listing candidate package.json files under apps/"
  ls -R apps 2>/dev/null || true
fi

if [ -z "$TARGET_DIR" ]; then
  echo "Error: could not determine target app directory. Set APP_DIR (e.g. apps/web) or APP_NAME (package.json name)." >&2
  exit 1
fi

if [ ! -d "$TARGET_DIR" ]; then
  echo "Error: resolved TARGET_DIR ($TARGET_DIR) does not exist." >&2
  exit 1
fi

REL_TARGET=${TARGET_DIR#${BUILD_DIR}/}
echo "Prepared workspace and dependencies for app in $TARGET_DIR (relative: ./$REL_TARGET)"

# NOTE: This buildpack intentionally does NOT run the app build. It prepares the monorepo
# (installs dependencies at the workspace root while ignoring lifecycle scripts) so that
# the official heroku/nodejs buildpack can perform the actual build with Node available.

exit 0
